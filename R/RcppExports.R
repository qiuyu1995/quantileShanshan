# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'Case-weight adjusted solution path for L2 regularized nonsmooth problem (quantile regression and svm)
#'
#' @description
#' Path-following algorithm to exactly solve 
#' 	(beta_{0,w}, beta_{w}) = argmin_{beta_0, beta} \sum_{i \neq j} f(g_i(beta_0, beta)) + w*f(g_{j}(beta_0, beta)) + lambda / 2 * \|beta\|_2^2
#' for 0 <= w <= 1, where g_i(beta_0, beta) = a_i beta_0 + b_i^T beta + c_i and f(r) = alpha_0 max(r, 0) + alpha_1 max(-r, 0)
#'
#' @param a A \eqn{n \times 1} vector and a^T = (a_1, ..., a_n)
#' @param B A \eqn{n \times p} matrix and B^T = (b_1, ..., b_n)
#' @param c A \eqn{n \times 1} matrix and c^T = (b_1, ..., b_n) 
#' @param lam Regularization parameter for L2 penalty
#' @param alpha_0 A scalar in the definition of f(r)
#' @param alpha_1 A scalar in the definition of f(r)
#' @param j Index of the observation that is attached a weight
#' @param beta_0_w0 A scalar, which is the true value of beta_{0,w} when w = w_0 = 1
#' @param beta_w0 A \eqn{p \times 1} vector, which is the true value of beta_{w} when w = w_0 = 1
#' @param theta_w0 A \eqn{n \times 1} vector, which is the true value of the dual variable when w = w_0 = 1
#'
#' @details
#' This function will be called by function CaseInfluence_nonsmooth to generate case influence graph for each case.
#'
#' @return W_vec A list of breakout points
#' @return Beta_0 True values of beta_{0,w} at breakout points
#' @return Beta True values of beta_{w} at breakout points
case_path_nonsmooth <- function(a, B, c, lam, alpha_0, alpha_1, j, beta_0_w0, beta_w0, theta_w0) {
    .Call(`_quantileShanshan_case_path_nonsmooth`, a, B, c, lam, alpha_0, alpha_1, j, beta_0_w0, beta_w0, theta_w0)
}

#' Lambda path for quantile regression
#'
#' @description
#' Path-following algorithm to exactly solve 
#' 	(beta_{0,w}, beta_{w}) = argmin_{beta_0, beta} \sum_{i \neq j} f(g_i(beta_0, beta)) + w*f(g_{j}(beta_0, beta)) + lambda / 2 * \|beta\|_2^2
#' for 0 <= w <= 1, where g_i(beta_0, beta) = a_i beta_0 + b_i^T beta + c_i and f(r) = alpha_0 max(r, 0) + alpha_1 max(-r, 0)
#'
#' @param y A \eqn{n \times 1} vector
#' @param X A \eqn{n \times p} matrix 
#' @param tau A scalar between 0 and 1
#'
#' @details
#'
#' @return enter_E_index Keep track which index enters set E at each step
#' @return lambda_vec A list of breakout points
#' @return beta_0 True values of beta_0 at breakout points
#' @return theta True values of theta at breakout points
LamPath <- function(y, X, tau) {
    .Call(`_quantileShanshan_LamPath`, y, X, tau)
}

#' Find solutions at any given lambda vector for regularized quantile regression
#'
#' @description
#'
#' @param y A \eqn{n \times 1} vector
#' @param X A \eqn{n \times p} matrix 
#' @param tau A scalar between 0 and 1
#' @param lambda_list A list of lambda, in descending order
#'
#' @details
#'
#' @return output First row is the beta_0, next p rows are beta and the last n rows are theta
solution_for_given_lambda <- function(y, X, tau, lambda_list) {
    .Call(`_quantileShanshan_solution_for_given_lambda`, y, X, tau, lambda_list)
}

Simulation_LamPath <- function(y, X, tau, lam_list) {
    .Call(`_quantileShanshan_Simulation_LamPath`, y, X, tau, lam_list)
}

#'Case-weight adjusted solution path for L2 regularized nonsmooth problem (quantile regression and svm)
#'
#' @description
#' Path-following algorithm to exactly solve 
#' 	(beta_{0,w}, beta_{w}) = argmin_{beta_0, beta} \sum_{i \neq j} f(g_i(beta_0, beta)) + w*f(g_{j}(beta_0, beta)) + lambda / 2 * \|beta\|_2^2
#' for 0 <= w <= 1, where g_i(beta_0, beta) = a_i beta_0 + b_i^T beta + c_i and f(r) = alpha_0 max(r, 0) + alpha_1 max(-r, 0)
#' with initial E/L/R, residual, and inverse matrix given.
NULL

w_path_simulation <- function(a, B, c, alpha_0, alpha_1, lam_list, beta_0_w0_list, beta_w0_mat, theta_w0_mat) {
    .Call(`_quantileShanshan_w_path_simulation`, a, B, c, alpha_0, alpha_1, lam_list, beta_0_w0_list, beta_w0_mat, theta_w0_mat)
}

